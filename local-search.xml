<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DNS简介</title>
    <link href="/2025/08/16/hello-world/"/>
    <url>/2025/08/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>DNS即Domain Name Server,即域名解析服务器，默认53端口、UDP连接、明文传输，可能会受到污染、劫持和监听。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><p>浏览器提取url中域名部分，首先查询浏览器缓存，若未命中，查询系统hosts文件，若未命中，则向出口网卡指定的DNS服务器发送请求。若未指定，则默认为为DHCP握手响应的DNS服务器，即一般是本地ISP的DNS服务器发起递归查询。本地ISP收到DNS请求后，查询缓存，若未命中，则向根（root)、顶级（TLD）及地方权威域名服务器发起迭代查询，如图1。浏览器收到响应后，根据TTL值将域名缓存到本地。<br><img src="/img/dns.png" alt="图1：DNS流程"/><br>More info: <a href="https://www.google.com/search?q=DNS">Search in Google</a></p><h3 id="劫持和污染"><a href="#劫持和污染" class="headerlink" title="劫持和污染"></a>劫持和污染</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nslookup google.com<br></code></pre></td></tr></table></figure><p>1.本地ISP出于审查和减少网间结算的目的，对DNS请求进行记录和劫持；<br>2.在国际入网口，GFW会按照黑名单封锁二级和三级域名，将大量域名污染到黑洞IP；<br>3.学校、企业等部署内网审计设备，通过上游部署旁路由，对53端口流量进行劫持和记录。<br>4.部分国产os会将用户指定的dns更改为受审查的dns。</p><p>More info: <a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93">维基百科：DNS污染</a></p><h3 id="直接输入IP可以吗？"><a href="#直接输入IP可以吗？" class="headerlink" title="直接输入IP可以吗？"></a>直接输入IP可以吗？</h3><p>如果DNS遇到污染，我们直接输入IP能否正常连接？我们知道，对于HTTPS网站，TCP握手后需要先建立安全的套接字协议连接，即TLS连接。如果直接在浏览器中输入IP，浏览器会根据HTTPS协议选择默认端口443。客户端发出sni字段留空的Client Hello请求。如果这个IP托管有多个服务器（证书），由于SNI无效，服务器只能向客户端投递“缺省证书”+公钥+哈希值签名，在客户端进行证书链验证时，会出现证书配置错误，无法进行安全连接。</p><h3 id="我的解决方案：OpenWrt-OpenClash-AdguardHome"><a href="#我的解决方案：OpenWrt-OpenClash-AdguardHome" class="headerlink" title="我的解决方案：OpenWrt+OpenClash+AdguardHome"></a>我的解决方案：OpenWrt+OpenClash+AdguardHome</h3><p>我一向不主张分流策略。分流DNS是不安全的行为。我们以Openwrt下Clash客户端为例。<br><a href="https://clash.wiki/configuration/dns.html"><img src="/img/clash.png"></a><br>OpenClash建立虚拟网卡ech0、注册ip rule，并监听0.0.0.0:53和::1:53。遇DNS请求时，OpenClash会根据域名解析策略（ip on demand&#x2F;ip if not match&#x2F;asls)处理这个域名。我们以默认的ip if not match策略为例，首先clash会匹配基于域名的规则，如匹配到Direct规则，则通过nameserver直接解析。如果nameserver本身包含域名，则由default nameserver充当其bootloader DNS服务器。如匹配到Proxy规则，则使用Clash DNS解析。<br>clash DNS也有2种处理模式，我们以常见的fake ip模式为例。当没有匹配到域名规则时，OpenClash首先会去匹配fakeip缓存，其次去匹配fakeip过滤器，如果在其中，则使用nameserver直连解析。否则将会建立一项fake ip映射表，真实ip由nameserver+proxy和fallback+proxy并行查询解析，取其最快响应ip。<br>这会造成，如果一个网站在html中通过js嵌入一些如”*.qq.com”的简单请求时，会导致用户的代理匹配基于域名的direct规则，使用直连DNS解析为国内CDN，并通过直连连接，造成了DNS泄漏和IP泄漏。在无跨域错误的情况下，网站可获得危险（实名）的国内IP，对用户造成安全隐患。<br>通过Openwrt作旁路由，上游网关指向主路由。DHCP服务器桥接真实网卡，将网关指向旁路由的静态IP。Adguard Home监听0.0.0.0:53，开启重定向，上游DNS为CLash监听DNS端口，Clash关闭53端口劫持。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSX中this对象绑定问题</title>
    <link href="/2025/08/16/day1/"/>
    <url>/2025/08/16/day1/</url>
    
    <content type="html"><![CDATA[<p>箭头函数内自动继承了上下文语义中的this对象；<br>在点引用直接调用中，引用对象this指针也会自动传递到被引用方法中。但点引用、引用调用和箭头函数同时出现时，容易混淆，我们把合法的写法做一个总结。我们先来看一段计时器示例：我们把index.html放在&#x2F;public文件夹下，把index.js,app.js,及全局样式表index.css放在&#x2F;source中：</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">import React from <span class="hljs-string">&#x27;react&#x27;</span>;<br>import ReactDOM from <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br>import <span class="hljs-string">&#x27;./index.css&#x27;</span>;<br>class Counter extends React.Component<br>&#123;<br>constructor(props)<br>&#123;<br>super(props);<br>this.state=&#123;count: 0&#125;;//状态对象初始化状态<br>&#125;<br> ()=&gt;<span class="hljs-function"><span class="hljs-title">Count</span></span>()<br>&#123;<br>this.setState(&#123;count: this.state.count+1&#125;);<br>&#125;<br><span class="hljs-function"><span class="hljs-title">render</span></span>()<br>&#123;<br><span class="hljs-built_in">return</span> (&lt;div&gt;&lt;h2&gt;The Count is &#123;this.state.count&#125;&lt;/h2&gt;&lt;p&gt;&lt;button onClick=&#123;this.Count&#125;&gt;+1&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;);<br>&#125;<br>&#125;<br>class Clocker extends React.Component<br>&#123;<br>constructor(props)<br>&#123;<br>super(props);//调用React.Component构造函数，此后this建立<br>this.state=&#123;<span class="hljs-built_in">date</span>:new Date()&#125;;//状态对象初始化状态，仅能出现在状态函数中<br>&#125;<br><span class="hljs-function"><span class="hljs-title">componentDidMount</span></span>()<br>&#123;<br>this.timerId=setInterval(()=&gt;this.tick(),<span class="hljs-number">1000</span>);<br>//默认单位为毫秒，即每隔<span class="hljs-number">1</span>s立即调用this.tick方法<br>&#125;<br>componentWillUnmount()<br>&#123;<br>clearInterval(this.timerId);<br>&#125;<br>tick()<br>&#123;<br>    this.setState(&#123;date:new Date()&#125;);<br>&#125;<br>render()<br>&#123;<br>return (&lt;div&gt;&lt;p&gt;The time is &#123;this.state.date.toLocaleTimeString()&#125;&lt;/p&gt;&lt;/div&gt;);<br>&#125;<br>&#125;<br>const test=ReactDOM.createRoot(document.getElementById(&quot;test&quot;));<br>const root=ReactDOM.createRoot(document.getElementById(<span class="hljs-string">&quot;root&quot;</span>));<br>root.render(&lt;Clocker/&gt;);<br>test.render(&lt;Counter/&gt;);<br></code></pre></td></tr></table></figure><p>为什么Clocker类方法tick()是普通函数，而Counter类方法Count必须是箭头函数呢？</p><p>写法1：<br><code>&lt;button onClick=&#123;this.Counter&#125;&gt;</code>，Counter()必须为箭头函数。这是一个引用调用，在执行主函数React.render(<Counter/>)时，由于只是取出Counter函数，不会发生死循环。<br>写法2：<br><code>&lt;button onClick=&#123;()=&gt;this.Counter()&#125;&gt;</code>这是一个匿名箭头函数，内部采用直接引用，因此在点击时不会出现“裸引用”，Counter既可以是普通函数，也可以是箭头函数。render继承当前实例的this，箭头函数内部继承render的this，Counter函数内部继承引用对象，即箭头函数里的this，不会出现undefined。<br>错误写法：<code>&lt;button onClick=&#123;this.Counter()&#125;</code>，这种情况下，编译时会出现render()-&gt;Counter()-&gt;setState()-&gt;render()死循环<br>错误写法：<code>&lt;button onClick=&#123;()=&gt;this.Count&#125;</code>,这种情况下，不会死循环，但点击无反应，因为箭头函数内部是引用调用。<br>错误写法：<code>&lt;button onCLick=&#123;this.Count&#125;</code>,且Count为普通函数。这种情况下，不会死循环，但点击时对“已取出”的方法Count进行“裸引用”，按钮无反应。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JSX,匿名箭头函数,点引用,私有状态</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
