<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Openwrt上通过AdguardHome和OpenClash部署私人DNS</title>
    <link href="/2025/08/16/hello-world/"/>
    <url>/2025/08/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>摘要：</p><ul><li>DNS污染与劫持</li><li>分流策略的潜在风险</li><li>为什么选择ASIS</li><li>搭建局域网私人DNS</li></ul><p>DNS即Domain Name Server,即域名解析服务器，默认53端口、UDP连接、明文传输，可能会受到污染、劫持和监听。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><p>浏览器提取url中域名部分，首先查询浏览器缓存，若未命中，查询系统hosts文件，若未命中，则向出口网卡指定的DNS服务器发送请求。若未指定，则默认为为DHCP握手响应的DNS服务器，即一般是本地ISP的DNS服务器发起递归查询。本地ISP收到DNS请求后，查询缓存，若未命中，则向根（root)、顶级（TLD）及地方权威域名服务器发起迭代查询，如图1。浏览器收到响应后，根据TTL值将域名缓存到本地。<br><img src="/img/dns.png" alt="图1：DNS流程"/><br>More info: <a href="https://www.google.com/search?q=DNS">Search in Google</a></p><h3 id="劫持和污染"><a href="#劫持和污染" class="headerlink" title="劫持和污染"></a>劫持和污染</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nslookup google.com<br></code></pre></td></tr></table></figure><p>1.本地ISP出于审查和减少网间结算的目的，对DNS请求进行记录和劫持；<br>2.在国际入网口，GFW会按照黑名单封锁二级和三级域名，将大量域名污染到黑洞IP；<br>3.学校、企业等部署内网审计设备，通过上游部署旁路由，对53端口流量进行劫持和记录。<br>4.部分国产os会将用户指定的dns更改为受审查的dns。</p><p>More info: <a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93">维基百科：DNS污染</a></p><h3 id="直接输入IP可以吗？"><a href="#直接输入IP可以吗？" class="headerlink" title="直接输入IP可以吗？"></a>直接输入IP可以吗？</h3><p>如果DNS遇到污染，我们直接输入IP能否正常连接？我们知道，对于HTTPS网站，TCP握手后需要先建立安全的套接字协议连接，即TLS连接。如果直接在浏览器中输入IP，浏览器会根据HTTPS协议选择默认端口443。客户端发出sni字段留空的Client Hello请求。如果这个IP托管有多个服务器（证书），由于SNI无效，服务器只能向客户端投递“缺省证书”+公钥+哈希值签名，在客户端进行证书链验证时，会出现证书配置错误，无法进行安全连接。</p><h3 id="不推荐使用分流"><a href="#不推荐使用分流" class="headerlink" title="不推荐使用分流"></a>不推荐使用分流</h3><p>我一向不主张分流策略。对于Clash-Core，分流DNS是不安全的行为。我们以Openwrt下Clash客户端为例。<br><a href="https://clash.wiki/configuration/dns.html"><img src="/img/clash.png"></a><br>OpenClash建立虚拟网卡ech0、注册ip rule，并监听0.0.0.0:53和::1:53。遇DNS请求时，OpenClash会根据域名解析策略（ip on demand&#x2F;ip if not match&#x2F;asls)处理这个域名。<br>clash DNS也有2种处理模式，我们以常见的fake ip模式为例。当没有匹配到域名规则时，OpenClash首先会去匹配fakeip缓存，其次去匹配fakeip过滤器，如果在其中，则使用nameserver直连解析。否则将会建立一项fake ip映射表，真实ip由nameserver+proxy和fallback+proxy并行查询解析，取其最快响应ip。<br>这会造成，如果一个网站在html中通过js嵌入一些如”*.qq.com”的简单请求时，会导致用户的代理匹配基于域名的direct规则，使用直连DNS解析为国内CDN，并通过直连连接，造成了DNS泄漏和IP泄漏。在无跨域错误的情况下，网站可获得危险（实名）的国内IP，对用户造成安全隐患。</p><h3 id="为什么选用ASIS"><a href="#为什么选用ASIS" class="headerlink" title="为什么选用ASIS"></a>为什么选用ASIS</h3><p>若策略为ip if not match，首先clash会匹配基于域名的规则，如匹配到Direct规则，则通过直连DNS直接解析。若没有匹配到基于域名的规则，则使用本地DNS将域名解析为IP，使用IP进行匹配。如果nameserver本身包含域名，则由default nameserver充当其bootloader DNS服务器。如匹配到Proxy规则，则使用Clash DNS解析。<br>若策略为ip on demand，首先clash会使用本地DNS将域名解析为IP，接下来匹配基于域名和IP的规则，进行匹配。<br>这两种策略，都会有本地DNS泄漏的问题。</p><h3 id="我的解决方案：OpenWrt-OpenClash-AdguardHome"><a href="#我的解决方案：OpenWrt-OpenClash-AdguardHome" class="headerlink" title="我的解决方案：OpenWrt+OpenClash+AdguardHome"></a>我的解决方案：OpenWrt+OpenClash+AdguardHome</h3><p>通过Openwrt作旁路由，上游网关指向主路由，主路由用于拨号，盘路由上运行DHCP服务器桥接真实网卡，将网关指向旁路由的静态IP。Adguard Home监听0.0.0.0:53，开启重定向，上游DNS为CLash监听DNS端口，Clash关闭53端口劫持。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React JSX 中的 this 绑定与事件处理机制</title>
    <link href="/2025/08/16/day1/"/>
    <url>/2025/08/16/day1/</url>
    
    <content type="html"><![CDATA[<p>箭头函数（Arrow Function）通过词法作用域（Lexical Scoping）特性，自动捕获定义时的上下文 <code>this</code> 指针。<br>在 JavaScript 类组件中，当使用点符号”.”直接调用成员方法时，<code>this</code> 指向通常能够正确传递,但在 React 的 JSX 事件处理场景下，将点符号引用、直接调用与箭头函数混合使用时，极易因 <code>this</code> 绑定机制引发混淆。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>我们假设目录结构如下：<code>index.html</code> 位于 <code>/public</code>，<code>index.js</code>, <code>app.js</code>, 及全局样式 <code>index.css</code> 位于 <code>/source</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>        <span class="hljs-comment">// 初始化组件状态</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br>    &#125;<br>    <span class="hljs-title class_">Count</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// 使用 setState 更新状态，触发重新渲染</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>The Count is &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">                    &#123;/* 事件绑定：传递函数引用 */&#125;</span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.Count&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clocker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(props);<br>        <span class="hljs-comment">// 建立 React.Component 实例</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() &#125;;<br>    &#125;<br><br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 设置定时器</span><br>        <span class="hljs-comment">// 箭头函数 () =&gt; this.tick() 捕获了 componentDidMount 作用域内的 this (即组件实例)</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">tick</span>(), <span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 清除定时器，防止内存泄漏</span><br>        <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timerId</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 原生类方法，未自动绑定 this</span><br>    <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() &#125;);<br>    &#125;<br><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> (<br>            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The time is &#123;this.state.date.toLocaleTimeString()&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> testRoot = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>));<br><span class="hljs-keyword">const</span> mainRoot = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>));<br><br>mainRoot.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clocker</span> /&gt;</span></span>);<br>testRoot.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span></span>);<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么Clocker类方法tick()是普通函数，而Counter类方法Count必须是箭头函数呢？</p><h1 id="写法1："><a href="#写法1：" class="headerlink" title="写法1："></a>写法1：</h1><p><code>&lt;button onClick=&#123;this.Counter&#125;&gt;</code>，Counter()必须为箭头函数。这是一个引用调用，在执行主函数React.render(<Counter/>)时，由于只是取出Counter函数，不会发生死循环。</p><h1 id="写法2："><a href="#写法2：" class="headerlink" title="写法2："></a>写法2：</h1><p><code>&lt;button onClick=&#123;()=&gt;this.Counter()&#125;&gt;</code>这是一个匿名箭头函数，内部采用直接引用，因此在点击时不会出现“裸引用”，Counter既可以是普通函数，也可以是箭头函数。render继承当前实例的this，箭头函数内部继承render的this，Counter函数内部继承引用对象，即箭头函数里的this，不会出现undefined。</p><h1 id="错误写法"><a href="#错误写法" class="headerlink" title="错误写法"></a>错误写法</h1><p>错误写法：<code>&lt;button onClick=&#123;this.Counter()&#125;</code>，这种情况下，编译时会出现render()-&gt;Counter()-&gt;setState()-&gt;render()死循环</p><p>错误写法：<code>&lt;button onClick=&#123;()=&gt;this.Count&#125;</code>,这种情况下，不会死循环，但点击无反应，因为箭头函数内部是引用调用。</p><p>错误写法：<code>&lt;button onCLick=&#123;this.Count&#125;</code>,且Count为普通函数。这种情况下，不会死循环，但点击时对“已取出”的方法Count进行“裸引用”，按钮无反应。</p>]]></content>
    
    
    
    <tags>
      
      <tag>React, JSX, 箭头函数, 词法作用域, 事件委托</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
